{"version":3,"file":"helpers.mjs","sources":["../../src/moj/helpers.mjs"],"sourcesContent":["export function removeAttributeValue(el, attr, value) {\n  let re, m\n  if (el.getAttribute(attr)) {\n    if (el.getAttribute(attr) === value) {\n      el.removeAttribute(attr)\n    } else {\n      re = new RegExp(`(^|\\\\s)${value}(\\\\s|$)`)\n      m = el.getAttribute(attr).match(re)\n      if (m && m.length === 3) {\n        el.setAttribute(\n          attr,\n          el.getAttribute(attr).replace(re, m[1] && m[2] ? ' ' : '')\n        )\n      }\n    }\n  }\n}\n\nexport function addAttributeValue(el, attr, value) {\n  let re\n  if (!el.getAttribute(attr)) {\n    el.setAttribute(attr, value)\n  } else {\n    re = new RegExp(`(^|\\\\s)${value}(\\\\s|$)`)\n    if (!re.test(el.getAttribute(attr))) {\n      el.setAttribute(attr, `${el.getAttribute(attr)} ${value}`)\n    }\n  }\n}\n\nexport function dragAndDropSupported() {\n  const div = document.createElement('div')\n  return typeof div.ondrop !== 'undefined'\n}\n\nexport function formDataSupported() {\n  return typeof FormData === 'function'\n}\n\nexport function fileApiSupported() {\n  const input = document.createElement('input')\n  input.type = 'file'\n  return typeof input.files !== 'undefined'\n}\n\nexport function nodeListForEach(nodes, callback) {\n  if (window.NodeList.prototype.forEach) {\n    return nodes.forEach(callback)\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    callback.call(window, nodes[i], i, nodes)\n  }\n}\n\n/**\n * Find an elements next sibling\n *\n * Utility function to find an elements next sibling matching the provided\n * selector.\n *\n * @param {HTMLElement} $element - Element to find siblings for\n * @param {string} selector - selector for required sibling\n */\nexport function getNextSibling($element, selector) {\n  if (!$element) return\n  // Get the next sibling element\n  let $sibling = $element.nextElementSibling\n\n  // If there's no selector, return the first sibling\n  if (!selector) return $sibling\n\n  // If the sibling matches our selector, use it\n  // If not, jump to the next sibling and continue the loop\n  while ($sibling) {\n    if ($sibling.matches(selector)) return $sibling\n    $sibling = $sibling.nextElementSibling\n  }\n}\n\n/**\n * Find an elements preceding sibling\n *\n * Utility function to find an elements previous sibling matching the provided\n * selector.\n *\n * @param {HTMLElement} $element - Element to find siblings for\n * @param {string} selector - selector for required sibling\n */\nexport function getPreviousSibling($element, selector) {\n  if (!$element) return\n  // Get the previous sibling element\n  let $sibling = $element.previousElementSibling\n\n  // If there's no selector, return the first sibling\n  if (!selector) return $sibling\n\n  // If the sibling matches our selector, use it\n  // If not, jump to the next sibling and continue the loop\n  while ($sibling) {\n    if ($sibling.matches(selector)) return $sibling\n    $sibling = $sibling.previousElementSibling\n  }\n}\n\nexport function findNearestMatchingElement($element, selector) {\n  // If no element or selector is provided, return null\n  if (!$element) return\n  if (!selector) return\n\n  // Start with the current element\n  let $currentElement = $element\n\n  while ($currentElement) {\n    // First check the current element\n    if ($currentElement.matches(selector)) {\n      return $currentElement\n    }\n\n    // Check all previous siblings\n    let $sibling = $currentElement.previousElementSibling\n    while ($sibling) {\n      // Check if the sibling itself is a heading\n      if ($sibling.matches(selector)) {\n        return $sibling\n      }\n      $sibling = $sibling.previousElementSibling\n    }\n\n    // If no match found in siblings, move up to parent\n    $currentElement = $currentElement.parentElement\n  }\n}\n\n/**\n * Move focus to element\n *\n * Sets tabindex to -1 to make the element programmatically focusable,\n * but removes it on blur as the element doesn't need to be focused again.\n *\n * @param {HTMLElement} $element - HTML element\n * @param {object} [options] - Handler options\n * @param {function(this: HTMLElement): void} [options.onBeforeFocus] - Callback before focus\n * @param {function(this: HTMLElement): void} [options.onBlur] - Callback on blur\n */\nexport function setFocus($element, options = {}) {\n  const isFocusable = $element.getAttribute('tabindex')\n\n  if (!isFocusable) {\n    $element.setAttribute('tabindex', '-1')\n  }\n\n  /**\n   * Handle element focus\n   */\n  function onFocus() {\n    $element.addEventListener('blur', onBlur, { once: true })\n  }\n\n  /**\n   * Handle element blur\n   */\n  function onBlur() {\n    if (options.onBlur) {\n      options.onBlur.call($element)\n    }\n\n    if (!isFocusable) {\n      $element.removeAttribute('tabindex')\n    }\n  }\n\n  // Add listener to reset element on blur, after focus\n  $element.addEventListener('focus', onFocus, { once: true })\n\n  // Focus element\n  if (options.onBeforeFocus) {\n    options.onBeforeFocus.call($element)\n  }\n  $element.focus()\n}\n"],"names":[],"mappings":"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"}